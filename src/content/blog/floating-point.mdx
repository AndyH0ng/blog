---
title: "부동 소수점에 대한 이해"
description: "0.1 + 0.2 != 0.3 인 이유가 뭘까?"
pubDate: "2024 09 18"
published: true
tags: ["CSE"]
---

## 부동 소수점 이해하기
컴퓨터가 실수를 표현하는 방법은 크게 두 가지로 나눌 수 있다.

> 고정 소수점 혹은 부동 소수점

이때 대부분의 컴퓨터는 부동 소수점 방식을 사용하여 소수를 표현한다.
이는 고정 소수점에 비해 같은 자원을 사용하여 더 큰 수를 표현할 수 있기 때문이다.
역으로 말하면 같은 수를 표현할 경우 고정 소수점 방식은 더 적은 자원을 소비한다는 소리.

## 고정 소수점 (Fixed Point)

고정 소수점 방식으로 실수형 자료는 다음과 같이 저장된다.

이때 소수의 부호를 나타내기 위한 여분의 메모리셀 부호 비트를 도입하였다. 2의 보수 표현과 결이 다른 부분. 양수의 경우 `0`, 음수의 경우 `1`이 된다.

굳이 고정 소수점을 구하는 법에 대해서는 설명하지 않겠다.

부동 소수점을 구하기 위해서는 고정 소수점을 구할 수 있어야 하기에, 구하는 법을 알지 못하는 독자가 있다면 학습 후 텍스트를 이어서 수용하기를 권장한다.

## 부동 소수점 (Floating Point) : IEEE-754

부동 소수점으로 소수를 표현하는 방법은 국제전기전자기술자협회(IEEE)에서 IEEE-754라는 이름으로 표준화되었다.

부동 소수점 또한 고정 소수점과 동일하게 부호 비트가 존재한다. 반면 정수부과 소수부 대신, 지수부와 가수부가 존재한다.


한편 C언어의 실수형 자료형은 다음과 같은 메모리 구조를 가진다.

|              | 부호   | 지수     | 가수      | 총                |
| ------------ | ---- | ------ | ------- | ---------------- |
| `float`      | 1bit | 8bits  | 23bits  | 32bits = 4Btye   |
| `double`     | 1bit | 11bits | 52bits  | 64bits = 8Byte   |
| `__float128` | 1bit | 15bits | 112bits | 128bits = 16Byte |
> `float`는 부동 소수점을 뜻하는 `floating point`에서 유래하였고, `double`은 단순히 `float`보다 자료형의 크기가 2배 크기에 `double`로 명명되었다.


## 과학적 표기

부동 소수점에 들어가기 앞서, 과학적 표기에 대해서 알아보자.

우리는 1mol을 다음과 같이 이해한다.

$$
1 mol = 6.02 \times 10 ^ {23}
$$

이처럼 소수를 곱셈과 거듭제곱을 사용하여 간단히 표기함을 과학적 표기 (Scientific Notation) 라 일컫는다.

구조를 일반화하면 다음과 같다.

$$
f \times b ^ e
$$

(이때 $f$ 는 가수, $b$ 는 밑, $e$ 는 지수. )

위 예시에서 $6.02$ 는 가수 ( $f$ ), $10$ 은 밑, $23$ 은 지수( $e$ )인 셈이다.

컴퓨터 또한 같은 방식으로 소수를 표현하지만, 이진 체계를 이용하기에, 밑은 $2$ 로 고정된다.



## 부동 소수점 표현하기

이해를 돕기 위해 8bits (부호 1bit, 지수부 3bits, 가수부 4bits) 크기에 실수형 자료 $0.34$ 를 저장한다고 가정해보자.

$$0.34_{(10)} = 0.010101110..._{(2)}$$

1. 고정 소수점 변환: 이진 체계를 이용하여 정수부와 소수부로 나눈다.

$$1.0101110... \times 2 ^ {-2}$$

2. 정규화: 과학적 표기를 거친다. 즉, 정수 부분이 $1$ 이 될 때까지 비트를 좌우로 shift한다. 이후 '정수 부분'의 $1$ 은 무시하며, 이 $1$ 을 Hidden Bit라고 부르기도 한다. 남은 비트는 가수부에 채워넣는다.

| 부호  | 지수 0 | 지수 1 | 지수 2 | 가수 0 | 가수 1 | 가수 2 | 가수 3 |
| --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0   |      |      |      | 0    | 1    | 0    | 1    |

$$-2 + 3 = 1$$

3. 지수부 표현: shift한 수에 bias를 더한 수를 지수부에 채워넣는다. (bias에 대해서는 다음 챕터에서 다룬다.)

| 부호  | 지수 0 | 지수 1 | 지수 2 | 가수 0 | 가수 1 | 가수 2 | 가수 3 |
| --- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0   | 0    | 0    | 1    | 0    | 1    | 0    | 1    |


## bias? 굳이 왜?

bias의 크기는 다음과 같다.
$$
2^{E - 1} - 1 \;\;\;(지수부의\,크기 = E)
$$

(편의를 위해 shift한 횟수 = $e$ 로 하자. 여기서 지수부의 크기는 8bits로 가정한다.)

지수부에 $e$ 하나 던져주면 되지, 왜 굳이 이런 수를 더할까?

세 번 shift 연산해서 지수부에 `0000 0011` 저장하면 그만 아닌가?

문제는 $e$ 가 음수일 경우 드러난다.

만약 `-3`이라면 어떻게 표현할 건가?

이 때문에 결국 $-127$ ~ $128$ 까지의 수에서

$[-127, 0]$ 까지는 $[0, 127]$,

$(0, 128]$ 까지는 $(127, 255]$ 로 나눠먹기로 한 것이다.

## 지수부에 2의 보수를 쓰지 않은 이유

표준화되지 않은 이유는 여러 가지가 있다.

### 1. 근사치의 부호

IEEE-754를 설계한 [Kahan에 따르면](https://people.freebsd.org/%7Edas/kahan86branch.pdf) 이로 인해 bias를 도입하였다고 한다.
부동 소수점의 근사치로 +0과 -0을 개별적으로 지정하기 위함이라 하는데, 필자는 솔직히 무슨 소린지 잘 모르겠다...

### 2. 2의 보수 사용 시 크기 비교의 어려움

사실 지수부를 표현할 때 2의 보수 표현을 사용하지 않는 것은 아니다!

IEEE-754 이전의 체계에선 이 방식을 주로 활용했고, 오늘날에도 연구되고 있다고 한다. [논문 참조](https://hal.archives-ouvertes.fr/hal-00157268/document)

